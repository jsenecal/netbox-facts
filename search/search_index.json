{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#netbox-facts-plugin","title":"NetBox Facts Plugin","text":"<p>Gather operational facts from supported NetBox Devices</p> <ul> <li>Free software: Apache-2.0</li> <li>Documentation: https://jsenecal.github.io/netbox-facts</li> </ul>"},{"location":"#features","title":"Features","text":"<p>This plugin leverages NAPALM to gather and document operational information about NetBox devices and various models.</p>"},{"location":"#compatibility","title":"Compatibility","text":"NetBox Version Plugin Version 3.7 0.0.1"},{"location":"#installing","title":"Installing","text":"<p>For adding to a NetBox Docker setup see the general instructions for using netbox-docker with plugins.</p> <p>While this is still in development and not yet on pypi you can install with pip:</p> <pre><code>pip install git+https://github.com/jsenecal/netbox-facts\n</code></pre> <p>or by adding to your <code>local_requirements.txt</code> or <code>plugin_requirements.txt</code> (netbox-docker):</p> <pre><code>git+https://github.com/jsenecal/netbox-facts\n</code></pre> <p>Enable the plugin in <code>/opt/netbox/netbox/netbox/configuration.py</code>,  or if you use netbox-docker, your <code>/configuration/plugins.py</code> file :</p> <pre><code>PLUGINS = [\n    'netbox_facts'\n]\n\nPLUGINS_CONFIG = {\n    \"netbox_facts\": {},\n}\n</code></pre>"},{"location":"#developing","title":"Developing","text":""},{"location":"#vscode--docker--dev-containers","title":"VSCode + Docker + Dev Containers","text":"<p>To develop this plugin further one can use the included .devcontainer configuration. This configuration creates a docker container which includes a fully working netbox installation. Currently it should work when using WSL 2. For this to work make sure you have Docker Desktop installed and the WSL 2 integrations activated.</p> <ol> <li>In the WSL terminal, enter <code>code</code> to run Visual studio code.</li> <li>Install the devcontainer extension \"ms-vscode-remote.remote-containers\"</li> <li>Press Ctrl+Shift+P and use the \"Dev Container: Clone Repository in Container Volume\" function to clone this repository. This will take a while depending on your computer</li> <li>Start the netbox instance using <code>make all</code></li> </ol> <p>Your netbox instance will be served under 0.0.0.0:8008, so it should now be available under localhost:8008.</p>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the <code>netbox-community/cookiecutter-netbox-plugin</code> project template.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#changelog","title":"Changelog","text":""},{"location":"changelog/#001-2023-08-02","title":"0.0.1 (2023-08-02)","text":"<ul> <li>First release on PyPI.</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contributing","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/jsenecal/netbox-facts/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"Bug\" and \"Help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"Feature\" and \"Help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>The NetBox Facts Plugin could always use more documentation, whether as part of the official NetBox Facts Plugin docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/jsenecal/netbox-facts/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions   are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up <code>netbox_facts</code> for local development.</p> <ol> <li>Fork the <code>netbox-facts</code> repo on GitHub.</li> <li> <p>Clone your fork locally</p> <pre><code>$ git clone git@github.com:your_name_here/netbox-facts.git\n</code></pre> </li> <li> <p>Install dependencies and start your virtualenv:</p> <pre><code>$ poetry install -E test -E doc -E dev\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass the    tests, including testing other Python versions, with tox:</p> <pre><code>$ poetry run tox\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated. Put    your new functionality into a function with a docstring, and add the    feature to the list in README.md.</li> <li>The pull request should work for Python 3.9 and above. Check    https://github.com/jsenecal/netbox-facts/actions    and make sure that the tests pass for all supported Python versions.</li> </ol>"},{"location":"contributing/#deploying","title":"Deploying","text":"<p>A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in CHANGELOG.md). Then run:</p> <pre><code>$ poetry run bump2version patch # possible: major / minor / patch\n$ git push\n$ git push --tags\n</code></pre> <p>GitHub Actions will then deploy to PyPI if tests pass.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/","title":"2026 02 26 phase2 phase3 design","text":""},{"location":"plans/2026-02-26-phase2-phase3-design/#design-phase-2--phase-3--auto-scheduling-standard--vendor-specific-collectors","title":"Design: Phase 2 + Phase 3 \u2014 Auto-Scheduling, Standard &amp; Vendor-Specific Collectors","text":"<p>Date: 2026-02-26 Status: Approved Scope: Phase 2 (auto-scheduling + standard NAPALM collectors) and Phase 3 (vendor-specific collectors)</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#context","title":"Context","text":"<p>Phase 1 is complete: runtime bugs fixed, UI forms/filters wired, tests added, dead code removed (commit <code>e531adc</code>). This design covers the remaining work to bring NetBox Facts to full functionality.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#implementation-approach","title":"Implementation Approach","text":"<p>Bottom-Up: Build in dependency order \u2014 jobs refactor first, then auto-scheduling, then standard collectors (simple to complex), then vendor-specific collectors. Tests accompany each piece.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#1-jobs-refactor--auto-scheduling","title":"1. Jobs Refactor + Auto-Scheduling","text":""},{"location":"plans/2026-02-26-phase2-phase3-design/#11-adopt-netboxs-jobrunner-pattern","title":"1.1 Adopt NetBox's JobRunner Pattern","text":"<p>Problem: The plugin uses a custom <code>CollectionPlan.enqueue()</code> classmethod that duplicates NetBox's <code>Job.enqueue()</code> without <code>transaction.on_commit()</code> safety or duplicate prevention. The <code>enqueue_collection_job(request)</code> method requires a request object, preventing signal-based scheduling.</p> <p>Solution: Create a <code>CollectionJobRunner(JobRunner)</code> subclass following the <code>SyncDataSourceJob</code> pattern from <code>core/jobs.py</code>.</p> <p>Files changed: - <code>netbox_facts/jobs.py</code> \u2014 Replace raw <code>collection_job()</code> function with <code>CollectionJobRunner</code> class - <code>netbox_facts/models/collection_plan.py</code> \u2014 Remove custom <code>enqueue()</code> classmethod, refactor <code>enqueue_collection_job()</code> to use <code>CollectionJobRunner.enqueue()</code>, make <code>run()</code> work without a request</p> <p>CollectionJobRunner design: - Override <code>enqueue()</code> to pass <code>queue_name=instance.priority</code> (preserving per-plan queue selection) - Override <code>enqueue()</code> to update CollectionPlan status to QUEUED - <code>run()</code> calls <code>CollectionPlan.run(request=None)</code> for signal path, <code>CollectionPlan.run(request=request)</code> for manual trigger - Auto-rescheduling handled by <code>JobRunner.handle()</code> when <code>interval</code> is set</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#12-auto-scheduling-signal","title":"1.2 Auto-Scheduling Signal","text":"<p>Pattern: Mirrors <code>core/signals.py:enqueue_sync_job</code> for DataSource.</p> <p><code>netbox_facts/signals.py</code> \u2014 <code>handle_collection_job_change</code>: - On post_save of CollectionPlan:   - If <code>enabled=True</code> and <code>interval</code> is set: call <code>CollectionJobRunner.enqueue_once(instance, interval, user=instance.run_as, queue_name=instance.priority)</code>   - If <code>enabled=False</code> or interval cleared (and not a new instance): delete pending scheduled jobs - <code>enqueue_once()</code> provides advisory locking to prevent duplicate schedules</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#13-collectionplanrun-refactor","title":"1.3 CollectionPlan.run() Refactor","text":"<p>Make <code>request</code> parameter optional. When called from signal/scheduled path (no request), skip <code>event_tracking</code> context manager or use a minimal context. The <code>event_tracking</code> context is only needed when the run is triggered by a user action with a real HTTP request.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#2-standard-napalm-collectors","title":"2. Standard NAPALM Collectors","text":"<p>All methods in <code>netbox_facts/helpers/collector.py</code>, following the existing <code>_ip_neighbors()</code> / <code>arp()</code> / <code>ndp()</code> pattern. Each receives a <code>driver: NetworkDriver</code> argument.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#21-inventorydriver--driverget_facts","title":"2.1 <code>inventory(driver)</code> \u2014 <code>driver.get_facts()</code>","text":"<ul> <li>Collects: hostname, vendor, model, serial, OS version, interface list</li> <li>Updates: Device.serial if changed</li> <li>Creates: JournalEntry documenting any changes detected</li> <li>Sets <code>discovery_method='inventory'</code> on any created objects</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#22-interfacesdriver--driverget_interfaces--driverget_interfaces_ip","title":"2.2 <code>interfaces(driver)</code> \u2014 <code>driver.get_interfaces()</code> + <code>driver.get_interfaces_ip()</code>","text":"<ul> <li>Collects: interface status, speed, MTU, MAC, description, IPs</li> <li>Creates: MACAddress for each interface's hardware MAC</li> <li>Sets: <code>MACAddress.device_interface</code> FK to link MAC to its owning interface</li> <li>Sets: <code>discovery_method='interfaces'</code>, <code>last_seen=now</code></li> <li>Updates: Interface description/MTU if different from NetBox (with journal entry)</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#23-ethernet_switchingdriver--driverget_mac_address_table","title":"2.3 <code>ethernet_switching(driver)</code> \u2014 <code>driver.get_mac_address_table()</code>","text":"<ul> <li>Collects: learned MAC addresses per interface/VLAN</li> <li>Creates: MACAddress objects with interface M2M associations</li> <li>L2-only \u2014 no IP correlation</li> <li>Sets: <code>discovery_method='ethernet_switching'</code>, <code>last_seen=now</code></li> <li>Handles: static vs dynamic entries, filters by <code>_interfaces_re</code></li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#24-lldpdriver--driverget_lldp_neighbors_detail","title":"2.4 <code>lldp(driver)</code> \u2014 <code>driver.get_lldp_neighbors_detail()</code>","text":"<ul> <li>Collects: remote chassis ID, system name, port, description</li> <li>Cable creation constraints:</li> <li>Both local and remote devices must exist in NetBox</li> <li>Both must be in the same Site (no cross-site cables)</li> <li>Both interfaces must exist and not already be cabled</li> <li>If constraints not met: log info/warning and skip</li> <li>Tags created cables with \"Automatically Discovered\"</li> <li>Creates: JournalEntry on cable creation</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#25-bgpdriver--driverget_bgp_neighbors_detail","title":"2.5 <code>bgp(driver)</code> \u2014 <code>driver.get_bgp_neighbors_detail()</code>","text":"<ul> <li>Collects: BGP peer state, AS numbers, prefix counts, per-VRF</li> <li>Creates/finds: ASN objects (<code>ipam.ASN</code>) for remote AS numbers</li> <li>Creates/finds: IPAddress for peer IPs (with VRF awareness)</li> <li>Tags peer IPs with \"Automatically Discovered\"</li> <li>Conditional <code>netbox-routing</code> integration:</li> <li>At import time, check if <code>netbox_routing</code> is importable</li> <li>If available: create/update BGP session objects linking local device to peer</li> <li>If unavailable: graceful fallback \u2014 only create IP/ASN objects, log info message</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#3-vendor-specific-collectors-junos-only","title":"3. Vendor-Specific Collectors (Junos Only)","text":""},{"location":"plans/2026-02-26-phase2-phase3-design/#31-extensibility-pattern","title":"3.1 Extensibility Pattern","text":"<p>Registry-style dispatch in collector:</p> <pre><code>def _get_vendor_method(self, method_name):\n    vendor_map = {\n        'junos': f'_{method_name}_junos',\n        'netbox_facts.napalm.junos': f'_{method_name}_junos',\n    }\n    driver_name = self.plan.napalm_driver\n    impl_name = vendor_map.get(driver_name)\n    if impl_name and hasattr(self, impl_name):\n        return getattr(self, impl_name)\n    raise NotImplementedError(\n        f\"{method_name} is not implemented for driver '{driver_name}'. \"\n        f\"Supported drivers: {list(vendor_map.keys())}\"\n    )\n</code></pre> <p>To add a new vendor: implement <code>_{method}_{vendor}()</code> and add to <code>vendor_map</code>.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#32-l2_circuitsdriver","title":"3.2 <code>l2_circuits(driver)</code>","text":"<ul> <li>Dispatches to <code>_l2_circuits_junos(driver)</code></li> <li>Junos: Uses NETCONF tables to parse L2 circuit connections</li> <li>Records: circuit ID, remote PE, interface, status</li> <li>Creates: JournalEntry documenting L2 circuit state</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#33-evpndriver","title":"3.3 <code>evpn(driver)</code>","text":"<ul> <li>Dispatches to <code>_evpn_junos(driver)</code></li> <li>Junos: Parses EVPN instance data via NETCONF</li> <li>Records: instance name, route targets, VLAN-to-VNI mappings</li> <li>Creates: MACAddress objects for learned EVPN MACs with <code>discovery_method='evpn'</code></li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#34-ospfdriver","title":"3.4 <code>ospf(driver)</code>","text":"<ul> <li>Dispatches to <code>_ospf_junos(driver)</code></li> <li>Junos: Parses OSPF neighbor adjacencies via NETCONF tables</li> <li>Records: neighbor ID, state, interface, area</li> <li>Conditional <code>netbox-routing</code> integration for OSPF neighbor data</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#35-enhancedjunosdriver-changes","title":"3.5 EnhancedJunOSDriver Changes","text":"<ul> <li><code>netbox_facts/napalm/junos.py</code> \u2014 Add methods for L2 circuit, EVPN, OSPF data retrieval</li> <li><code>netbox_facts/napalm/utils/junos_views.py</code> \u2014 Add NETCONF table definitions for new data types</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#4-testing-strategy","title":"4. Testing Strategy","text":""},{"location":"plans/2026-02-26-phase2-phase3-design/#new-test-files","title":"New Test Files","text":"<ul> <li><code>netbox_facts/tests/test_jobs.py</code> \u2014 CollectionJobRunner tests</li> <li><code>netbox_facts/tests/test_signals.py</code> \u2014 Auto-scheduling signal tests</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#expanded-test-files","title":"Expanded Test Files","text":"<ul> <li><code>netbox_facts/tests/test_helpers.py</code> \u2014 Tests for each collector method</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-design/#test-approach","title":"Test Approach","text":"<p>Collectors: Mock NAPALM driver returning known data structures. Verify correct NetBox objects created/updated. Test edge cases (missing interfaces, empty tables, unreachable devices).</p> <p>Scheduling: Verify <code>enqueue_once()</code> called on save with <code>enabled=True</code> + <code>interval</code>. Verify jobs deleted on <code>enabled=False</code>. Verify duplicate prevention.</p> <p>LLDP: Same-site cable creation works. Cross-site skipped with log. Missing device/interface handled gracefully.</p> <p>BGP with netbox-routing: Mock as installed \u2192 verify session creation. Mock as absent \u2192 verify IP/ASN-only fallback.</p> <p>Vendor-specific: Mock NETCONF responses. Verify NotImplementedError for unsupported drivers.</p>"},{"location":"plans/2026-02-26-phase2-phase3-design/#5-files-modified-summary","title":"5. Files Modified Summary","text":"File Changes <code>netbox_facts/jobs.py</code> Replace raw function with <code>CollectionJobRunner(JobRunner)</code> <code>netbox_facts/signals.py</code> Implement <code>handle_collection_job_change</code> with <code>enqueue_once()</code> <code>netbox_facts/models/collection_plan.py</code> Remove custom <code>enqueue()</code>, refactor <code>enqueue_collection_job()</code>, make <code>run()</code> request-optional <code>netbox_facts/helpers/collector.py</code> Implement all 8 collector methods + vendor dispatch <code>netbox_facts/napalm/junos.py</code> Add L2 circuit, EVPN, OSPF NETCONF methods <code>netbox_facts/napalm/utils/junos_views.py</code> Add NETCONF table definitions <code>netbox_facts/choices.py</code> Add OSPF to CollectionTypeChoices if missing <code>netbox_facts/tests/test_jobs.py</code> New \u2014 JobRunner tests <code>netbox_facts/tests/test_signals.py</code> New \u2014 Scheduling signal tests <code>netbox_facts/tests/test_helpers.py</code> Expand \u2014 Collector method tests <code>.devcontainer/</code> Add <code>netbox-routing</code> as dev dependency"},{"location":"plans/2026-02-26-phase2-phase3-design/#6-implementation-order","title":"6. Implementation Order","text":"<ol> <li>Jobs refactor (JobRunner subclass)</li> <li>Auto-scheduling signal</li> <li><code>inventory()</code> collector</li> <li><code>interfaces()</code> collector</li> <li><code>ethernet_switching()</code> collector</li> <li><code>lldp()</code> collector</li> <li><code>bgp()</code> collector + netbox-routing integration</li> <li>Vendor dispatch framework</li> <li><code>l2_circuits()</code> Junos implementation</li> <li><code>evpn()</code> Junos implementation</li> <li><code>ospf()</code> Junos implementation + netbox-routing integration</li> <li>Tests for all of the above</li> </ol>"},{"location":"plans/2026-02-26-phase2-phase3-design/#design-decisions","title":"Design Decisions","text":"<ul> <li>JobRunner over custom enqueue: NetBox 4.x <code>Job.enqueue()</code> supports <code>queue_name</code>, eliminating the need for the plugin's custom implementation</li> <li>LLDP same-site only: Cables only created between devices in the same Site to avoid incorrect cross-location topology</li> <li>LLDP no device creation: Does not create Device objects for unknown LLDP neighbors</li> <li>BGP netbox-routing conditional: Runtime import check; graceful fallback if plugin not installed</li> <li>Vendor dispatch registry: Simple dict-based dispatch, extensible by adding methods + map entries</li> <li>Junos only for Phase 3: Clear extension points documented for adding other vendors</li> </ul>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/","title":"2026 02 26 phase2 phase3 implementation","text":""},{"location":"plans/2026-02-26-phase2-phase3-implementation/#phase-23-implementation-plan","title":"Phase 2+3 Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Implement auto-scheduling via JobRunner, 5 standard NAPALM collectors, 3 vendor-specific Junos collectors, and conditional netbox-routing integration.</p> <p>Architecture: Adopts NetBox's <code>JobRunner</code> pattern (from <code>netbox/jobs.py</code>) for job management. Collectors follow the existing <code>_ip_neighbors()</code>/<code>arp()</code> pattern in <code>collector.py</code>. Vendor-specific collectors use a registry-based dispatch. <code>netbox-routing</code> integration is conditional at import time.</p> <p>Tech Stack: Django 4.x, NetBox 4.5.x, NAPALM 4.1, django-rq, netbox-routing (optional)</p> <p>Test runner: <code>make test</code> (runs <code>manage.py makemigrations --check &amp;&amp; manage.py test netbox_facts</code>)</p> <p>Design doc: <code>docs/plans/2026-02-26-phase2-phase3-design.md</code></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-1-add-ospf-to-collectiontypechoices--migration","title":"Task 1: Add OSPF to CollectionTypeChoices + Migration","text":"<p>Files: - Modify: <code>netbox_facts/choices.py</code> - Create: <code>netbox_facts/migrations/0022_*.py</code> (auto-generated)</p> <p>Step 1: Add OSPF choice</p> <p>In <code>netbox_facts/choices.py</code>, add <code>TYPE_OSPF = \"ospf\"</code> and append to <code>CHOICES</code>:</p> <pre><code>class CollectionTypeChoices(ChoiceSet):\n    key = \"Collection.Type\"\n\n    TYPE_ARP = \"arp\"\n    TYPE_NDP = \"ndp\"\n    TYPE_INVENTORY = \"inventory\"\n    TYPE_INTERFACES = \"interfaces\"\n    TYPE_LLDP = \"lldp\"\n    TYPE_L2 = \"ethernet_switching\"\n    TYPE_L2CIRCTUITS = \"l2_circuits\"\n    TYPE_EVPN = \"evpn\"\n    TYPE_BGP = \"bgp\"\n    TYPE_OSPF = \"ospf\"\n\n    CHOICES = [\n        (TYPE_ARP, \"ARP\", \"gray\"),\n        (TYPE_NDP, _(\"IPv6 Neighbor Discovery\"), \"gray\"),\n        (TYPE_INVENTORY, _(\"Inventory\"), \"blue\"),\n        (TYPE_INTERFACES, _(\"Interfaces\"), \"purple\"),\n        (TYPE_LLDP, _(\"LLDP\"), \"cyan\"),\n        (TYPE_L2, _(\"Ethernet Switching Tables\"), \"black\"),\n        (TYPE_L2CIRCTUITS, _(\"L2 Circuits\"), \"orange\"),\n        (TYPE_EVPN, \"EVPN\", \"red\"),\n        (TYPE_BGP, \"BGP\", \"green\"),\n        (TYPE_OSPF, \"OSPF\", \"teal\"),\n    ]\n</code></pre> <p>Step 2: Generate and apply migration</p> <pre><code>make migrations\nmake migrate\n</code></pre> <p>Step 3: Verify</p> <p><pre><code>make test\n</code></pre> Expected: All existing tests pass, migration check clean.</p> <p>Step 4: Commit</p> <pre><code>git add netbox_facts/choices.py netbox_facts/migrations/0022_*\ngit commit -m \"Add OSPF to CollectionTypeChoices\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-2-refactor-jobs-to-use-jobrunner-pattern","title":"Task 2: Refactor Jobs to Use JobRunner Pattern","text":"<p>Files: - Modify: <code>netbox_facts/jobs.py</code> - Modify: <code>netbox_facts/models/collection_plan.py</code> - Modify: <code>netbox_facts/views.py</code> (update <code>CollectorRunView</code> to use new enqueue) - Create: <code>netbox_facts/tests/test_jobs.py</code></p> <p>Context: NetBox's <code>JobRunner</code> (at <code>/opt/netbox/netbox/netbox/jobs.py:54</code>) is an ABC that wraps <code>Job.enqueue()</code> with lifecycle management (<code>handle()</code> \u2192 <code>start()</code> \u2192 <code>run()</code> \u2192 <code>terminate()</code>), automatic rescheduling for interval-based jobs, and duplicate prevention via <code>enqueue_once()</code>. The canonical example is <code>SyncDataSourceJob</code> in <code>/opt/netbox/netbox/core/jobs.py:20</code>.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests-for-collectionjobrunner","title":"Step 1: Write failing tests for CollectionJobRunner","text":"<p>Create <code>netbox_facts/tests/test_jobs.py</code>:</p> <pre><code>from unittest.mock import patch, MagicMock\n\nfrom django.test import TestCase\nfrom dcim.choices import DeviceStatusChoices\n\nfrom netbox_facts.choices import CollectionTypeChoices, CollectorStatusChoices\nfrom netbox_facts.jobs import CollectionJobRunner\nfrom netbox_facts.models import CollectionPlan\n\n\nclass CollectionJobRunnerTest(TestCase):\n    \"\"\"Tests for CollectionJobRunner.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.plan = CollectionPlan.objects.create(\n            name=\"Job Test Plan\",\n            collector_type=CollectionTypeChoices.TYPE_ARP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n\n    def test_runner_name(self):\n        \"\"\"CollectionJobRunner.name should be 'Facts Collection'.\"\"\"\n        self.assertEqual(CollectionJobRunner.name, \"Facts Collection\")\n\n    @patch(\"netbox_facts.jobs.CollectionPlan\")\n    def test_enqueue_sets_status_to_queued(self, mock_plan_cls):\n        \"\"\"enqueue() should update the plan status to QUEUED.\"\"\"\n        mock_plan_cls.objects.filter.return_value.update = MagicMock()\n\n        with patch(\"core.models.jobs.Job.enqueue\") as mock_enqueue:\n            mock_job = MagicMock()\n            mock_job.object = self.plan\n            mock_enqueue.return_value = mock_job\n\n            CollectionJobRunner.enqueue(\n                instance=self.plan,\n                user=None,\n                queue_name=self.plan.priority,\n            )\n\n            mock_plan_cls.objects.filter.assert_called_with(pk=self.plan.pk)\n\n    @patch(\"netbox_facts.jobs.CollectionPlan\")\n    def test_run_calls_plan_run(self, mock_plan_cls):\n        \"\"\"run() should fetch the plan and call plan.run().\"\"\"\n        mock_plan = MagicMock()\n        mock_plan_cls.objects.get.return_value = mock_plan\n\n        mock_job = MagicMock()\n        mock_job.object_id = self.plan.pk\n\n        runner = CollectionJobRunner(mock_job)\n        runner.run()\n\n        mock_plan_cls.objects.get.assert_called_once_with(pk=self.plan.pk)\n        mock_plan.run.assert_called_once()\n\n    @patch(\"netbox_facts.jobs.CollectionPlan\")\n    def test_run_passes_request_kwarg(self, mock_plan_cls):\n        \"\"\"run() should forward the request kwarg to plan.run().\"\"\"\n        mock_plan = MagicMock()\n        mock_plan_cls.objects.get.return_value = mock_plan\n        mock_request = MagicMock()\n\n        mock_job = MagicMock()\n        mock_job.object_id = self.plan.pk\n\n        runner = CollectionJobRunner(mock_job)\n        runner.run(request=mock_request)\n\n        mock_plan.run.assert_called_once_with(request=mock_request)\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-run-tests-to-verify-they-fail","title":"Step 2: Run tests to verify they fail","text":"<p><pre><code>make test\n</code></pre> Expected: ImportError or AttributeError \u2014 <code>CollectionJobRunner</code> doesn't exist yet.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-implement-collectionjobrunner","title":"Step 3: Implement CollectionJobRunner","text":"<p>Replace <code>netbox_facts/jobs.py</code> with:</p> <pre><code>import logging\n\nfrom netbox.jobs import JobRunner\n\nfrom netbox_facts.choices import CollectorStatusChoices\n\nlogger = logging.getLogger(__name__)\n\n\nclass CollectionJobRunner(JobRunner):\n    \"\"\"JobRunner for NetBox Facts collection jobs.\"\"\"\n\n    class Meta:\n        name = \"Facts Collection\"\n\n    @classmethod\n    def enqueue(cls, *args, **kwargs):\n        \"\"\"Enqueue a collection job, setting the plan status to QUEUED.\"\"\"\n        from netbox_facts.models import CollectionPlan\n\n        job = super().enqueue(*args, **kwargs)\n\n        # Update the CollectionPlan's status to queued\n        if instance := job.object:\n            instance.status = CollectorStatusChoices.QUEUED\n            CollectionPlan.objects.filter(pk=instance.pk).update(\n                status=CollectorStatusChoices.QUEUED\n            )\n\n        return job\n\n    def run(self, request=None, *args, **kwargs):\n        \"\"\"Execute the collection plan.\"\"\"\n        from netbox_facts.models import CollectionPlan\n\n        plan = CollectionPlan.objects.get(pk=self.job.object_id)\n        plan.run(request=request)\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-4-refactor-collectionplan-model","title":"Step 4: Refactor CollectionPlan model","text":"<p>In <code>netbox_facts/models/collection_plan.py</code>:</p> <p>4a. Remove the custom <code>enqueue()</code> classmethod (lines 320-370). Delete the entire <code>enqueue()</code> method.</p> <p>4b. Refactor <code>enqueue_collection_job()</code> to use <code>CollectionJobRunner</code>:</p> <pre><code>def enqueue_collection_job(self, request):\n    \"\"\"\n    Enqueue a background job to perform the facts collection.\n    \"\"\"\n    from netbox_facts.jobs import CollectionJobRunner\n\n    user = (\n        self.run_as\n        if request.user.is_superuser and self.run_as is not None\n        else request.user\n    )\n\n    self.current_job = CollectionJobRunner.enqueue(\n        instance=self,\n        user=user,\n        queue_name=self.priority,\n        request=copy_safe_request(request),\n    )\n    return self.current_job\n</code></pre> <p>4c. Make <code>run()</code> work without a request:</p> <pre><code>def run(\n    self, request=None, *args, **kwargs\n):  # pylint: disable=missing-function-docstring,unused-argument\n    if self.status == CollectorStatusChoices.WORKING:\n        raise OperationNotSupported(\n            \"Cannot initiate collection job; Collector already working.\"\n        )\n\n    self.status = CollectorStatusChoices.WORKING\n    CollectionPlan.objects.filter(pk=self.pk).update(status=self.status)\n\n    napalm_args = self.get_napalm_args()\n    if napalm_args and napalm_args.get(\"debug\", False):\n        import debugpy  # pylint: disable=import-outside-toplevel\n\n        debugpy.listen((\"0.0.0.0\", 5678))\n        debugpy.wait_for_client()  # blocks execution until client is attached\n        self.napalm_args.pop(\"debug\")\n\n    # Create a new NapalmCollector instance\n    runner = NapalmCollector(self)\n\n    if request:\n        with event_tracking(request):\n            runner.execute()\n    else:\n        runner.execute()\n\n    # Update status &amp; last_synced time\n    self.status = CollectorStatusChoices.COMPLETED\n    self.last_run = timezone.now()\n    CollectionPlan.objects.filter(pk=self.pk).update(\n        status=self.status, last_run=self.last_run\n    )\n</code></pre> <p>4d. Remove now-unused imports from <code>collection_plan.py</code>: - Remove <code>import django_rq</code> - Remove <code>import uuid</code> - Remove <code>from django.utils.module_loading import import_string</code> - Keep <code>from utilities.request import copy_safe_request</code> (still used in <code>enqueue_collection_job</code>)</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-5-run-tests","title":"Step 5: Run tests","text":"<p><pre><code>make test\n</code></pre> Expected: All tests pass.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-6-commit","title":"Step 6: Commit","text":"<pre><code>git add netbox_facts/jobs.py netbox_facts/models/collection_plan.py netbox_facts/tests/test_jobs.py\ngit commit -m \"Refactor jobs to use NetBox JobRunner pattern\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-3-implement-auto-scheduling-signal","title":"Task 3: Implement Auto-Scheduling Signal","text":"<p>Files: - Modify: <code>netbox_facts/signals.py</code> - Create: <code>netbox_facts/tests/test_signals.py</code></p> <p>Context: Mirrors <code>core/signals.py:enqueue_sync_job</code> (line 266) which handles DataSource periodic sync scheduling.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests","title":"Step 1: Write failing tests","text":"<p>Create <code>netbox_facts/tests/test_signals.py</code>:</p> <pre><code>from unittest.mock import patch, MagicMock\n\nfrom django.test import TestCase\nfrom dcim.choices import DeviceStatusChoices\n\nfrom netbox_facts.choices import CollectionTypeChoices\nfrom netbox_facts.models import CollectionPlan\n\n\nclass HandleCollectionJobChangeSignalTest(TestCase):\n    \"\"\"Tests for the handle_collection_job_change signal.\"\"\"\n\n    def _create_plan(self, **kwargs):\n        defaults = {\n            \"name\": \"Signal Test Plan\",\n            \"collector_type\": CollectionTypeChoices.TYPE_ARP,\n            \"napalm_driver\": \"junos\",\n            \"device_status\": [DeviceStatusChoices.STATUS_ACTIVE],\n        }\n        defaults.update(kwargs)\n        return CollectionPlan(**defaults)\n\n    @patch(\"netbox_facts.signals.CollectionJobRunner\")\n    def test_enqueue_once_called_when_enabled_with_interval(self, mock_runner):\n        \"\"\"Saving an enabled plan with interval should call enqueue_once.\"\"\"\n        plan = self._create_plan(enabled=True, interval=60)\n        plan.save()\n\n        mock_runner.enqueue_once.assert_called_once()\n        call_kwargs = mock_runner.enqueue_once.call_args\n        self.assertEqual(call_kwargs.kwargs.get(\"interval\") or call_kwargs[1].get(\"interval\", call_kwargs[0][1] if len(call_kwargs[0]) &gt; 1 else None), 60)\n\n    @patch(\"netbox_facts.signals.CollectionJobRunner\")\n    def test_no_enqueue_when_disabled(self, mock_runner):\n        \"\"\"Saving a disabled plan should not call enqueue_once.\"\"\"\n        plan = self._create_plan(enabled=False, interval=60)\n        plan.save()\n\n        mock_runner.enqueue_once.assert_not_called()\n\n    @patch(\"netbox_facts.signals.CollectionJobRunner\")\n    def test_no_enqueue_when_no_interval(self, mock_runner):\n        \"\"\"Saving an enabled plan without interval should not call enqueue_once.\"\"\"\n        plan = self._create_plan(enabled=True, interval=None)\n        plan.save()\n\n        mock_runner.enqueue_once.assert_not_called()\n\n    @patch(\"netbox_facts.signals.CollectionJobRunner\")\n    def test_deletes_jobs_when_disabled(self, mock_runner):\n        \"\"\"Disabling a plan should delete pending scheduled jobs.\"\"\"\n        # Create the plan first (enabled)\n        plan = self._create_plan(enabled=True, interval=60, name=\"Delete Test Plan\")\n        plan.save()\n        mock_runner.reset_mock()\n\n        # Now disable it\n        plan.enabled = False\n        plan.save()\n\n        # Should have called get_jobs to find and delete pending jobs\n        mock_runner.get_jobs.assert_called()\n\n    @patch(\"netbox_facts.signals.CollectionJobRunner\")\n    def test_deletes_jobs_when_interval_cleared(self, mock_runner):\n        \"\"\"Clearing interval on existing plan should delete pending jobs.\"\"\"\n        plan = self._create_plan(enabled=True, interval=60, name=\"Interval Clear Plan\")\n        plan.save()\n        mock_runner.reset_mock()\n\n        # Clear interval\n        plan.interval = None\n        plan.save()\n\n        mock_runner.enqueue_once.assert_not_called()\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-run-tests-to-verify-they-fail_1","title":"Step 2: Run tests to verify they fail","text":"<p><pre><code>make test\n</code></pre> Expected: Tests fail because signal handler is still <code>pass</code>.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-implement-the-signal-handler","title":"Step 3: Implement the signal handler","text":"<p>Replace <code>handle_collection_job_change</code> in <code>netbox_facts/signals.py</code>:</p> <pre><code>from django.db.models.signals import post_save\nfrom django.dispatch import receiver\n\nfrom core.choices import JobStatusChoices\nfrom dcim.models.devices import Manufacturer\n\nfrom .models import MACAddress, MACVendor, CollectionPlan\n\n\n@receiver(post_save, sender=MACAddress)\ndef handle_mac_change(\n    instance: MACAddress, **kwargs\n):  # pylint: disable=unused-argument\n    # ... existing code unchanged ...\n\n\n@receiver(post_save, sender=MACVendor)\ndef handle_mac_vendor_change(\n    instance: MACVendor, **kwargs\n):  # pylint: disable=unused-argument\n    # ... existing code unchanged ...\n\n\n@receiver(post_save, sender=CollectionPlan)\ndef handle_collection_job_change(\n    instance: CollectionPlan, created=False, **kwargs\n):  # pylint: disable=unused-argument\n    \"\"\"\n    Schedule or cancel collection jobs when a CollectionPlan is saved.\n    Mirrors the DataSource sync scheduling pattern from core/signals.py.\n    \"\"\"\n    from netbox_facts.jobs import CollectionJobRunner\n\n    if instance.enabled and instance.interval:\n        CollectionJobRunner.enqueue_once(\n            instance=instance,\n            interval=instance.interval,\n            user=instance.run_as,\n            queue_name=instance.priority,\n        )\n    elif not created:\n        # Delete any previously scheduled recurring jobs for this CollectionPlan\n        for job in CollectionJobRunner.get_jobs(instance).defer(\"data\").filter(\n            interval__isnull=False,\n            status=JobStatusChoices.STATUS_SCHEDULED,\n        ):\n            job.delete()\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-4-run-tests","title":"Step 4: Run tests","text":"<p><pre><code>make test\n</code></pre> Expected: All tests pass.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-5-commit","title":"Step 5: Commit","text":"<pre><code>git add netbox_facts/signals.py netbox_facts/tests/test_signals.py\ngit commit -m \"Implement auto-scheduling signal for CollectionPlan\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-4-implement-inventory-collector","title":"Task 4: Implement inventory() Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p> <p>Context: <code>driver.get_facts()</code> returns: <pre><code>{\n    'uptime': 151005.57,\n    'vendor': 'Arista',\n    'os_version': '4.14.3',\n    'serial_number': 'SN0123A34AS',\n    'model': 'vEOS',\n    'hostname': 'eos-router',\n    'fqdn': 'eos-router',\n    'interface_list': ['Ethernet2', 'Management1', 'Ethernet1']\n}\n</code></pre></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-test","title":"Step 1: Write failing test","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>from unittest.mock import MagicMock, patch, PropertyMock\nfrom django.test import TestCase\nfrom django.utils import timezone\nfrom dcim.choices import DeviceStatusChoices\nfrom dcim.models import Device, DeviceRole, DeviceType, Manufacturer, Site\nfrom extras.models.models import JournalEntry\n\nfrom netbox_facts.choices import CollectionTypeChoices\nfrom netbox_facts.helpers.collector import NapalmCollector\nfrom netbox_facts.models import CollectionPlan\n\n\nclass InventoryCollectorTest(TestCase):\n    \"\"\"Tests for the inventory() collector method.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"Inv Site\", slug=\"inv-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"InvMfg\", slug=\"invmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"InvModel\", slug=\"invmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"InvRole\", slug=\"invrole\")\n\n    def _make_collector(self, plan):\n        \"\"\"Create a NapalmCollector with mocked internals.\"\"\"\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        collector._interfaces_re = MagicMock()\n        collector._interfaces_re.match.return_value = True\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_inventory_updates_serial(self):\n        \"\"\"inventory() should update device serial from get_facts().\"\"\"\n        device = Device.objects.create(\n            name=\"inv-dev1\",\n            site=self.site,\n            device_type=self.device_type,\n            role=self.role,\n            serial=\"OLD_SERIAL\",\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"Inv Plan\",\n            collector_type=CollectionTypeChoices.TYPE_INVENTORY,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_facts.return_value = {\n            \"uptime\": 1000.0,\n            \"vendor\": \"Juniper\",\n            \"os_version\": \"21.4R3\",\n            \"serial_number\": \"NEW_SERIAL\",\n            \"model\": \"QFX5100\",\n            \"hostname\": \"inv-dev1\",\n            \"fqdn\": \"inv-dev1.example.com\",\n            \"interface_list\": [\"ge-0/0/0\", \"lo0\"],\n        }\n\n        collector.inventory(mock_driver)\n\n        device.refresh_from_db()\n        self.assertEqual(device.serial, \"NEW_SERIAL\")\n\n    def test_inventory_creates_journal_entry_on_change(self):\n        \"\"\"inventory() should create a journal entry when device data changes.\"\"\"\n        device = Device.objects.create(\n            name=\"inv-dev2\",\n            site=self.site,\n            device_type=self.device_type,\n            role=self.role,\n            serial=\"\",\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"Inv Plan 2\",\n            collector_type=CollectionTypeChoices.TYPE_INVENTORY,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_facts.return_value = {\n            \"uptime\": 2000.0,\n            \"vendor\": \"Juniper\",\n            \"os_version\": \"22.1R1\",\n            \"serial_number\": \"SN123\",\n            \"model\": \"QFX5100\",\n            \"hostname\": \"inv-dev2\",\n            \"fqdn\": \"inv-dev2.example.com\",\n            \"interface_list\": [],\n        }\n\n        collector.inventory(mock_driver)\n\n        entries = JournalEntry.objects.filter(\n            assigned_object_id=device.pk,\n        )\n        self.assertTrue(entries.exists())\n\n    def test_inventory_no_change_no_journal(self):\n        \"\"\"inventory() should NOT create a journal entry when nothing changes.\"\"\"\n        device = Device.objects.create(\n            name=\"inv-dev3\",\n            site=self.site,\n            device_type=self.device_type,\n            role=self.role,\n            serial=\"SAME_SERIAL\",\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"Inv Plan 3\",\n            collector_type=CollectionTypeChoices.TYPE_INVENTORY,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_facts.return_value = {\n            \"uptime\": 3000.0,\n            \"vendor\": \"Juniper\",\n            \"os_version\": \"\",\n            \"serial_number\": \"SAME_SERIAL\",\n            \"model\": \"QFX5100\",\n            \"hostname\": \"inv-dev3\",\n            \"fqdn\": \"inv-dev3.example.com\",\n            \"interface_list\": [],\n        }\n\n        collector.inventory(mock_driver)\n\n        entries = JournalEntry.objects.filter(assigned_object_id=device.pk)\n        self.assertFalse(entries.exists())\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-run-tests-to-verify-they-fail_2","title":"Step 2: Run tests to verify they fail","text":"<p><pre><code>make test\n</code></pre> Expected: <code>NotImplementedError</code> from <code>inventory()</code>.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-implement-inventory","title":"Step 3: Implement inventory()","text":"<p>In <code>netbox_facts/helpers/collector.py</code>, replace the <code>inventory()</code> stub:</p> <pre><code>def inventory(self, driver: NetworkDriver):\n    \"\"\"Collect inventory data from a device using get_facts().\"\"\"\n    facts = driver.get_facts()\n    device = self._current_device\n    changes = []\n\n    # Update serial number if changed\n    new_serial = facts.get(\"serial_number\", \"\")\n    if new_serial and device.serial != new_serial:\n        changes.append(f\"Serial: `{device.serial}` \u2192 `{new_serial}`\")\n        Device.objects.filter(pk=device.pk).update(serial=new_serial)\n\n    # Log OS version info\n    os_version = facts.get(\"os_version\", \"\")\n    if os_version:\n        changes.append(f\"OS version: `{os_version}`\")\n\n    # Log hostname info\n    hostname = facts.get(\"hostname\", \"\")\n    fqdn = facts.get(\"fqdn\", \"\")\n    if hostname:\n        changes.append(f\"Hostname: `{hostname}`\" + (f\" (FQDN: `{fqdn}`)\" if fqdn else \"\"))\n\n    # Create journal entry if there were changes\n    if new_serial and device.serial != new_serial:\n        JournalEntry.objects.create(\n            created=self._now,\n            assigned_object=device,\n            kind=JournalEntryKindChoices.KIND_INFO,\n            comments=f\"Inventory facts collected:\\n\" + \"\\n\".join(f\"- {c}\" for c in changes),\n        )\n\n    self._log_success(\"Inventory collection completed\")\n</code></pre> <p>Wait \u2014 there's a bug in the logic above. The serial comparison after update won't work because we already updated it. Fix:</p> <pre><code>def inventory(self, driver: NetworkDriver):\n    \"\"\"Collect inventory data from a device using get_facts().\"\"\"\n    facts = driver.get_facts()\n    device = self._current_device\n    changes = []\n    serial_changed = False\n\n    # Check serial number\n    new_serial = facts.get(\"serial_number\", \"\")\n    if new_serial and device.serial != new_serial:\n        changes.append(f\"Serial: `{device.serial}` \u2192 `{new_serial}`\")\n        Device.objects.filter(pk=device.pk).update(serial=new_serial)\n        serial_changed = True\n\n    # Log OS version info\n    os_version = facts.get(\"os_version\", \"\")\n    if os_version:\n        changes.append(f\"OS version: `{os_version}`\")\n\n    # Log hostname info\n    hostname = facts.get(\"hostname\", \"\")\n    fqdn = facts.get(\"fqdn\", \"\")\n    if hostname:\n        changes.append(f\"Hostname: `{hostname}`\" + (f\" (FQDN: `{fqdn}`)\" if fqdn else \"\"))\n\n    # Create journal entry only if actual data changed\n    if serial_changed:\n        JournalEntry.objects.create(\n            created=self._now,\n            assigned_object=device,\n            kind=JournalEntryKindChoices.KIND_INFO,\n            comments=f\"Inventory facts collected:\\n\" + \"\\n\".join(f\"- {c}\" for c in changes),\n        )\n\n    self._log_success(\"Inventory collection completed\")\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-4-run-tests_1","title":"Step 4: Run tests","text":"<p><pre><code>make test\n</code></pre> Expected: All tests pass.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-5-commit_1","title":"Step 5: Commit","text":"<pre><code>git add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement inventory() collector\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-5-implement-interfaces-collector","title":"Task 5: Implement interfaces() Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p> <p>Context: <code>driver.get_interfaces()</code> returns: <pre><code>{\n    'Ethernet1': {\n        'is_up': True, 'is_enabled': True, 'description': 'foo',\n        'last_flapped': 1429978575.15, 'speed': 1000.0, 'mtu': 1500,\n        'mac_address': 'FA:16:3E:57:33:62',\n    }\n}\n</code></pre></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests_1","title":"Step 1: Write failing tests","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>class InterfacesCollectorTest(TestCase):\n    \"\"\"Tests for the interfaces() collector method.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"Iface Site\", slug=\"iface-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"IfaceMfg\", slug=\"ifacemfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"IfaceModel\", slug=\"ifacemodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"IfaceRole\", slug=\"ifacerole\")\n\n    def _make_collector(self, plan):\n        \"\"\"Create a NapalmCollector with mocked internals.\"\"\"\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")  # Match all interfaces\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_interfaces_creates_mac_for_interface(self):\n        \"\"\"interfaces() should create MACAddress for each interface's hardware MAC.\"\"\"\n        from netbox_facts.models import MACAddress\n\n        device = Device.objects.create(\n            name=\"iface-dev1\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        from dcim.models import Interface\n        iface = Interface.objects.create(device=device, name=\"ge-0/0/0\", type=\"1000base-t\")\n\n        plan = CollectionPlan.objects.create(\n            name=\"Iface Plan\",\n            collector_type=CollectionTypeChoices.TYPE_INTERFACES,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_interfaces.return_value = {\n            \"ge-0/0/0\": {\n                \"is_up\": True, \"is_enabled\": True, \"description\": \"uplink\",\n                \"last_flapped\": -1.0, \"speed\": 1000.0, \"mtu\": 1500,\n                \"mac_address\": \"AA:BB:CC:11:22:33\",\n            },\n        }\n        mock_driver.get_interfaces_ip.return_value = {}\n\n        collector.interfaces(mock_driver)\n\n        self.assertTrue(MACAddress.objects.filter(mac_address=\"AA:BB:CC:11:22:33\").exists())\n        mac = MACAddress.objects.get(mac_address=\"AA:BB:CC:11:22:33\")\n        self.assertEqual(mac.device_interface, iface)\n        self.assertEqual(mac.discovery_method, CollectionTypeChoices.TYPE_INTERFACES)\n        self.assertIsNotNone(mac.last_seen)\n\n    def test_interfaces_skips_non_matching_interface(self):\n        \"\"\"interfaces() should skip interfaces that don't match the regex.\"\"\"\n        from netbox_facts.models import MACAddress\n        import re\n\n        device = Device.objects.create(\n            name=\"iface-dev2\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n\n        plan = CollectionPlan.objects.create(\n            name=\"Iface Plan 2\",\n            collector_type=CollectionTypeChoices.TYPE_INTERFACES,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._interfaces_re = re.compile(r\"^ge-\")  # Only ge- interfaces\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_interfaces.return_value = {\n            \"Management1\": {\n                \"is_up\": True, \"is_enabled\": True, \"description\": \"\",\n                \"last_flapped\": -1.0, \"speed\": 1000.0, \"mtu\": 1500,\n                \"mac_address\": \"AA:BB:CC:99:88:77\",\n            },\n        }\n        mock_driver.get_interfaces_ip.return_value = {}\n\n        collector.interfaces(mock_driver)\n\n        self.assertFalse(MACAddress.objects.filter(mac_address=\"AA:BB:CC:99:88:77\").exists())\n\n    def test_interfaces_skips_empty_mac(self):\n        \"\"\"interfaces() should skip interfaces with empty MAC address.\"\"\"\n        from netbox_facts.models import MACAddress\n\n        device = Device.objects.create(\n            name=\"iface-dev3\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        from dcim.models import Interface\n        Interface.objects.create(device=device, name=\"lo0\", type=\"virtual\")\n\n        plan = CollectionPlan.objects.create(\n            name=\"Iface Plan 3\",\n            collector_type=CollectionTypeChoices.TYPE_INTERFACES,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_interfaces.return_value = {\n            \"lo0\": {\n                \"is_up\": True, \"is_enabled\": True, \"description\": \"loopback\",\n                \"last_flapped\": -1.0, \"speed\": 0, \"mtu\": 65535,\n                \"mac_address\": \"\",\n            },\n        }\n        mock_driver.get_interfaces_ip.return_value = {}\n\n        initial_count = MACAddress.objects.count()\n        collector.interfaces(mock_driver)\n        self.assertEqual(MACAddress.objects.count(), initial_count)\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-run-tests-to-verify-failure-then-implement","title":"Step 2: Run tests to verify failure, then implement","text":"<p>In <code>netbox_facts/helpers/collector.py</code>, replace the <code>interfaces()</code> stub:</p> <pre><code>def interfaces(self, driver: NetworkDriver):\n    \"\"\"Collect interface data from a device.\"\"\"\n    ifaces = driver.get_interfaces()\n    ifaces_ip = driver.get_interfaces_ip()\n\n    for name, data in ifaces.items():\n        if not self._interfaces_re.match(name):\n            continue\n\n        # Get the matching interface from NetBox\n        try:\n            nb_iface = self._current_device.vc_interfaces().get(name=name)\n        except Interface.DoesNotExist:\n            self._log_warning(f\"Interface `{name}` not found in NetBox. Skipping.\")\n            continue\n\n        # Create/update MACAddress for interface hardware MAC\n        mac_addr = data.get(\"mac_address\", \"\")\n        if mac_addr:\n            netbox_mac, created = MACAddress.objects.get_or_create(\n                mac_address=mac_addr\n            )\n            netbox_mac.device_interface = nb_iface\n            netbox_mac.discovery_method = CollectionTypeChoices.TYPE_INTERFACES\n            netbox_mac.last_seen = self._now\n            netbox_mac.save()\n\n            if created:\n                netbox_mac.tags.add(AUTO_D_TAG)\n                self._log_success(\n                    f\"Created MAC address {get_absolute_url_markdown(netbox_mac, bold=True)} \"\n                    f\"for interface {get_absolute_url_markdown(nb_iface, bold=True)}.\"\n                )\n            else:\n                self._log_info(\n                    f\"Updated MAC address {get_absolute_url_markdown(netbox_mac, bold=True)} \"\n                    f\"for interface {get_absolute_url_markdown(nb_iface, bold=True)}.\"\n                )\n\n    self._log_success(\"Interface collection completed\")\n</code></pre> <p>Also add import at top of <code>collector.py</code>:</p> <pre><code>from netbox_facts.choices import CollectionTypeChoices\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests","title":"Step 3: Run tests","text":"<pre><code>make test\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-4-commit","title":"Step 4: Commit","text":"<pre><code>git add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement interfaces() collector\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-6-implement-ethernet_switching-collector","title":"Task 6: Implement ethernet_switching() Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p> <p>Context: <code>driver.get_mac_address_table()</code> returns: <pre><code>[\n    {'mac': '00:1C:58:29:4A:71', 'interface': 'Ethernet47', 'vlan': 100,\n     'static': False, 'active': True, 'moves': 1, 'last_move': 1454417742.58}\n]\n</code></pre></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests_2","title":"Step 1: Write failing tests","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>class EthernetSwitchingCollectorTest(TestCase):\n    \"\"\"Tests for the ethernet_switching() collector method.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"ES Site\", slug=\"es-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"ESMfg\", slug=\"esmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"ESModel\", slug=\"esmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"ESRole\", slug=\"esrole\")\n\n    def _make_collector(self, plan):\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_creates_mac_from_table(self):\n        \"\"\"ethernet_switching() should create MACAddress from MAC table entries.\"\"\"\n        from netbox_facts.models import MACAddress\n        from dcim.models import Interface\n\n        device = Device.objects.create(\n            name=\"es-dev1\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        iface = Interface.objects.create(device=device, name=\"ge-0/0/0\", type=\"1000base-t\")\n\n        plan = CollectionPlan.objects.create(\n            name=\"ES Plan\",\n            collector_type=CollectionTypeChoices.TYPE_L2,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_mac_address_table.return_value = [\n            {\n                \"mac\": \"00:1C:58:29:4A:71\",\n                \"interface\": \"ge-0/0/0\",\n                \"vlan\": 100,\n                \"static\": False,\n                \"active\": True,\n                \"moves\": 0,\n                \"last_move\": 0.0,\n            },\n        ]\n\n        collector.ethernet_switching(mock_driver)\n\n        self.assertTrue(MACAddress.objects.filter(mac_address=\"00:1C:58:29:4A:71\").exists())\n        mac = MACAddress.objects.get(mac_address=\"00:1C:58:29:4A:71\")\n        self.assertIn(iface, mac.interfaces.all())\n        self.assertEqual(mac.discovery_method, CollectionTypeChoices.TYPE_L2)\n\n    def test_skips_empty_mac(self):\n        \"\"\"ethernet_switching() should skip entries with empty MAC.\"\"\"\n        from netbox_facts.models import MACAddress\n\n        device = Device.objects.create(\n            name=\"es-dev2\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n\n        plan = CollectionPlan.objects.create(\n            name=\"ES Plan 2\",\n            collector_type=CollectionTypeChoices.TYPE_L2,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_mac_address_table.return_value = [\n            {\"mac\": \"\", \"interface\": \"ge-0/0/0\", \"vlan\": 1, \"static\": False, \"active\": True, \"moves\": 0, \"last_move\": 0.0},\n        ]\n\n        initial_count = MACAddress.objects.count()\n        collector.ethernet_switching(mock_driver)\n        self.assertEqual(MACAddress.objects.count(), initial_count)\n\n    def test_skips_interface_not_in_netbox(self):\n        \"\"\"ethernet_switching() should log warning for missing interfaces.\"\"\"\n        from netbox_facts.models import MACAddress\n\n        device = Device.objects.create(\n            name=\"es-dev3\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n\n        plan = CollectionPlan.objects.create(\n            name=\"ES Plan 3\",\n            collector_type=CollectionTypeChoices.TYPE_L2,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_mac_address_table.return_value = [\n            {\"mac\": \"AA:BB:CC:DD:EE:FF\", \"interface\": \"nonexistent\", \"vlan\": 1, \"static\": False, \"active\": True, \"moves\": 0, \"last_move\": 0.0},\n        ]\n\n        initial_count = MACAddress.objects.count()\n        collector.ethernet_switching(mock_driver)\n        self.assertEqual(MACAddress.objects.count(), initial_count)\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-implement-ethernet_switching","title":"Step 2: Implement ethernet_switching()","text":"<pre><code>def ethernet_switching(self, driver: NetworkDriver):\n    \"\"\"Collect MAC address table data from a device.\"\"\"\n    mac_table = driver.get_mac_address_table()\n\n    for entry in mac_table:\n        mac_addr = entry.get(\"mac\", \"\")\n        if not mac_addr:\n            continue\n\n        iface_name = entry.get(\"interface\", \"\")\n        if not iface_name or not self._interfaces_re.match(iface_name):\n            continue\n\n        try:\n            nb_iface = self._current_device.vc_interfaces().get(name=iface_name)\n        except Interface.DoesNotExist:\n            self._log_warning(\n                f\"Interface `{iface_name}` not found in NetBox for MAC `{mac_addr}`. Skipping.\"\n            )\n            continue\n\n        netbox_mac, created = MACAddress.objects.get_or_create(mac_address=mac_addr)\n        netbox_mac.interfaces.add(nb_iface)\n        netbox_mac.discovery_method = CollectionTypeChoices.TYPE_L2\n        netbox_mac.last_seen = self._now\n        netbox_mac.save()\n\n        if created:\n            netbox_mac.tags.add(AUTO_D_TAG)\n            self._log_success(\n                f\"Created MAC address {get_absolute_url_markdown(netbox_mac, bold=True)} \"\n                f\"on {get_absolute_url_markdown(nb_iface, bold=True)} (VLAN {entry.get('vlan', 'N/A')}).\"\n            )\n        else:\n            self._log_info(\n                f\"Updated MAC address {get_absolute_url_markdown(netbox_mac, bold=True)} \"\n                f\"on {get_absolute_url_markdown(nb_iface, bold=True)}.\"\n            )\n\n    self._log_success(\"Ethernet switching collection completed\")\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests-and-commit","title":"Step 3: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement ethernet_switching() collector\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-7-implement-lldp-collector","title":"Task 7: Implement lldp() Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p> <p>Context: <code>driver.get_lldp_neighbors_detail()</code> returns: <pre><code>{\n    'TenGigE0/0/0/8': [\n        {\n            'parent_interface': 'Bundle-Ether8',\n            'remote_chassis_id': '8c60.4f69.e96c',\n            'remote_system_name': 'switch',\n            'remote_port': 'Eth2/2/1',\n            'remote_port_description': 'Ethernet2/2/1',\n            'remote_system_description': 'Cisco NX-OS 7.1',\n            'remote_system_capab': ['bridge', 'repeater'],\n            'remote_system_enable_capab': ['bridge']\n        }\n    ]\n}\n</code></pre></p> <p>Constraints: Cables only created when both devices exist in NetBox AND are in the same Site. No new Device creation.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests_3","title":"Step 1: Write failing tests","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>class LLDPCollectorTest(TestCase):\n    \"\"\"Tests for the lldp() collector method.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"LLDP Site\", slug=\"lldp-site\")\n        cls.site2 = Site.objects.create(name=\"LLDP Site 2\", slug=\"lldp-site-2\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"LLDPMfg\", slug=\"lldpmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"LLDPModel\", slug=\"lldpmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"LLDPRole\", slug=\"lldprole\")\n\n    def _make_collector(self, plan):\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_creates_cable_same_site(self):\n        \"\"\"lldp() should create a cable between devices in the same site.\"\"\"\n        from dcim.models import Interface, Cable\n\n        local_device = Device.objects.create(\n            name=\"lldp-local\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        remote_device = Device.objects.create(\n            name=\"lldp-remote\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        local_iface = Interface.objects.create(device=local_device, name=\"ge-0/0/0\", type=\"1000base-t\")\n        remote_iface = Interface.objects.create(device=remote_device, name=\"ge-0/0/1\", type=\"1000base-t\")\n\n        plan = CollectionPlan.objects.create(\n            name=\"LLDP Plan\",\n            collector_type=CollectionTypeChoices.TYPE_LLDP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = local_device\n\n        mock_driver = MagicMock()\n        mock_driver.get_lldp_neighbors_detail.return_value = {\n            \"ge-0/0/0\": [\n                {\n                    \"parent_interface\": \"\",\n                    \"remote_chassis_id\": \"AA:BB:CC:DD:EE:FF\",\n                    \"remote_system_name\": \"lldp-remote\",\n                    \"remote_port\": \"ge-0/0/1\",\n                    \"remote_port_description\": \"\",\n                    \"remote_system_description\": \"Juniper\",\n                    \"remote_system_capab\": [\"router\"],\n                    \"remote_system_enable_capab\": [\"router\"],\n                },\n            ],\n        }\n\n        collector.lldp(mock_driver)\n\n        # Verify cable was created\n        local_iface.refresh_from_db()\n        self.assertIsNotNone(local_iface.cable)\n\n    def test_no_cable_cross_site(self):\n        \"\"\"lldp() should NOT create a cable between devices in different sites.\"\"\"\n        from dcim.models import Interface, Cable\n\n        local_device = Device.objects.create(\n            name=\"lldp-local2\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        remote_device = Device.objects.create(\n            name=\"lldp-remote2\", site=self.site2,\n            device_type=self.device_type, role=self.role,\n        )\n        local_iface = Interface.objects.create(device=local_device, name=\"ge-0/0/0\", type=\"1000base-t\")\n        remote_iface = Interface.objects.create(device=remote_device, name=\"ge-0/0/1\", type=\"1000base-t\")\n\n        plan = CollectionPlan.objects.create(\n            name=\"LLDP Plan 2\",\n            collector_type=CollectionTypeChoices.TYPE_LLDP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = local_device\n\n        mock_driver = MagicMock()\n        mock_driver.get_lldp_neighbors_detail.return_value = {\n            \"ge-0/0/0\": [\n                {\n                    \"parent_interface\": \"\",\n                    \"remote_chassis_id\": \"AA:BB:CC:DD:EE:FF\",\n                    \"remote_system_name\": \"lldp-remote2\",\n                    \"remote_port\": \"ge-0/0/1\",\n                    \"remote_port_description\": \"\",\n                    \"remote_system_description\": \"\",\n                    \"remote_system_capab\": [],\n                    \"remote_system_enable_capab\": [],\n                },\n            ],\n        }\n\n        collector.lldp(mock_driver)\n\n        local_iface.refresh_from_db()\n        self.assertIsNone(local_iface.cable)\n\n    def test_no_cable_unknown_remote_device(self):\n        \"\"\"lldp() should log info when remote device is not in NetBox.\"\"\"\n        from dcim.models import Interface\n\n        local_device = Device.objects.create(\n            name=\"lldp-local3\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        local_iface = Interface.objects.create(device=local_device, name=\"ge-0/0/0\", type=\"1000base-t\")\n\n        plan = CollectionPlan.objects.create(\n            name=\"LLDP Plan 3\",\n            collector_type=CollectionTypeChoices.TYPE_LLDP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = local_device\n\n        mock_driver = MagicMock()\n        mock_driver.get_lldp_neighbors_detail.return_value = {\n            \"ge-0/0/0\": [\n                {\n                    \"parent_interface\": \"\",\n                    \"remote_chassis_id\": \"AA:BB:CC:DD:EE:FF\",\n                    \"remote_system_name\": \"unknown-device\",\n                    \"remote_port\": \"eth0\",\n                    \"remote_port_description\": \"\",\n                    \"remote_system_description\": \"\",\n                    \"remote_system_capab\": [],\n                    \"remote_system_enable_capab\": [],\n                },\n            ],\n        }\n\n        collector.lldp(mock_driver)\n\n        local_iface.refresh_from_db()\n        self.assertIsNone(local_iface.cable)\n\n    def test_no_cable_already_cabled(self):\n        \"\"\"lldp() should not create duplicate cables.\"\"\"\n        from dcim.models import Interface, Cable\n\n        local_device = Device.objects.create(\n            name=\"lldp-local4\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        remote_device = Device.objects.create(\n            name=\"lldp-remote4\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        local_iface = Interface.objects.create(device=local_device, name=\"ge-0/0/0\", type=\"1000base-t\")\n        remote_iface = Interface.objects.create(device=remote_device, name=\"ge-0/0/1\", type=\"1000base-t\")\n\n        # Pre-create a cable\n        cable = Cable(a_terminations=[local_iface], b_terminations=[remote_iface])\n        cable.save()\n\n        plan = CollectionPlan.objects.create(\n            name=\"LLDP Plan 4\",\n            collector_type=CollectionTypeChoices.TYPE_LLDP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = local_device\n\n        mock_driver = MagicMock()\n        mock_driver.get_lldp_neighbors_detail.return_value = {\n            \"ge-0/0/0\": [\n                {\n                    \"parent_interface\": \"\",\n                    \"remote_chassis_id\": \"AA:BB:CC:DD:EE:FF\",\n                    \"remote_system_name\": \"lldp-remote4\",\n                    \"remote_port\": \"ge-0/0/1\",\n                    \"remote_port_description\": \"\",\n                    \"remote_system_description\": \"\",\n                    \"remote_system_capab\": [],\n                    \"remote_system_enable_capab\": [],\n                },\n            ],\n        }\n\n        initial_cable_count = Cable.objects.count()\n        collector.lldp(mock_driver)\n        self.assertEqual(Cable.objects.count(), initial_cable_count)\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-implement-lldp","title":"Step 2: Implement lldp()","text":"<p>Add imports at top of <code>collector.py</code>: <pre><code>from dcim.models.cables import Cable\nfrom dcim.choices import LinkStatusChoices\n</code></pre></p> <pre><code>def lldp(self, driver: NetworkDriver):\n    \"\"\"Collect LLDP neighbor data from a device.\"\"\"\n    neighbors = driver.get_lldp_neighbors_detail()\n\n    for local_iface_name, neighbor_list in neighbors.items():\n        if not self._interfaces_re.match(local_iface_name):\n            continue\n\n        try:\n            local_iface = self._current_device.vc_interfaces().get(name=local_iface_name)\n        except Interface.DoesNotExist:\n            self._log_warning(f\"Local interface `{local_iface_name}` not found in NetBox. Skipping.\")\n            continue\n\n        for neighbor in neighbor_list:\n            remote_name = neighbor.get(\"remote_system_name\", \"\")\n            remote_port = neighbor.get(\"remote_port\", \"\")\n\n            if not remote_name:\n                self._log_info(f\"LLDP neighbor on `{local_iface_name}` has no system name. Skipping.\")\n                continue\n\n            # Find remote device in NetBox\n            try:\n                remote_device = Device.objects.get(name=remote_name)\n            except Device.DoesNotExist:\n                self._log_info(\n                    f\"LLDP neighbor `{remote_name}` on `{local_iface_name}` not found in NetBox.\"\n                )\n                continue\n            except Device.MultipleObjectsReturned:\n                self._log_warning(\n                    f\"Multiple devices named `{remote_name}` in NetBox. Skipping.\"\n                )\n                continue\n\n            # Same site check\n            if remote_device.site_id != self._current_device.site_id:\n                self._log_info(\n                    f\"LLDP neighbor `{remote_name}` is in a different site \"\n                    f\"(`{remote_device.site}` vs `{self._current_device.site}`). Skipping cable.\"\n                )\n                continue\n\n            # Find remote interface\n            if not remote_port:\n                self._log_warning(f\"LLDP neighbor `{remote_name}` has no remote port. Skipping.\")\n                continue\n\n            try:\n                remote_iface = remote_device.vc_interfaces().get(name=remote_port)\n            except Interface.DoesNotExist:\n                self._log_warning(\n                    f\"Remote interface `{remote_port}` not found on `{remote_name}`. Skipping.\"\n                )\n                continue\n\n            # Check if either interface already has a cable\n            if local_iface.cable or remote_iface.cable:\n                self._log_info(\n                    f\"Interface `{local_iface_name}` or `{remote_port}` already cabled. Skipping.\"\n                )\n                continue\n\n            # Create cable\n            cable = Cable(\n                a_terminations=[local_iface],\n                b_terminations=[remote_iface],\n                status=LinkStatusChoices.STATUS_CONNECTED,\n            )\n            cable.full_clean()\n            cable.save()\n            cable.tags.add(AUTO_D_TAG)\n\n            JournalEntry.objects.create(\n                created=self._now,\n                assigned_object=self._current_device,\n                kind=JournalEntryKindChoices.KIND_INFO,\n                comments=(\n                    f\"LLDP discovered cable: \"\n                    f\"{get_absolute_url_markdown(local_iface, bold=True)} \u2194 \"\n                    f\"{get_absolute_url_markdown(remote_iface, bold=True)} \"\n                    f\"on {get_absolute_url_markdown(remote_device, bold=True)}\"\n                ),\n            )\n            self._log_success(\n                f\"Created cable between `{local_iface_name}` and \"\n                f\"`{remote_name}:{remote_port}`.\"\n            )\n\n    self._log_success(\"LLDP collection completed\")\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests-and-commit_1","title":"Step 3: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement lldp() collector with same-site cable creation\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-8-implement-bgp-collector","title":"Task 8: Implement bgp() Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p> <p>Context: <code>driver.get_bgp_neighbors_detail()</code> returns a nested dict: <code>{vrf_name: {as_number: [peer_details]}}</code>. NetBox has <code>ipam.ASN</code> (requires <code>rir</code> FK). Conditional <code>netbox-routing</code> integration deferred to Task 11.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests_4","title":"Step 1: Write failing tests","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>class BGPCollectorTest(TestCase):\n    \"\"\"Tests for the bgp() collector method.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"BGP Site\", slug=\"bgp-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"BGPMfg\", slug=\"bgpmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"BGPModel\", slug=\"bgpmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"BGPRole\", slug=\"bgprole\")\n\n    def _make_collector(self, plan):\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_creates_peer_ip(self):\n        \"\"\"bgp() should create IPAddress for discovered BGP peers.\"\"\"\n        from ipam.models import IPAddress\n\n        device = Device.objects.create(\n            name=\"bgp-dev1\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n\n        plan = CollectionPlan.objects.create(\n            name=\"BGP Plan\",\n            collector_type=CollectionTypeChoices.TYPE_BGP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_bgp_neighbors_detail.return_value = {\n            \"global\": {\n                65001: [\n                    {\n                        \"up\": True,\n                        \"local_as\": 65000,\n                        \"remote_as\": 65001,\n                        \"remote_address\": \"10.0.0.1\",\n                        \"local_address\": \"10.0.0.2\",\n                        \"router_id\": \"10.0.0.1\",\n                        \"connection_state\": \"Established\",\n                        \"active_prefix_count\": 100,\n                        \"received_prefix_count\": 150,\n                        \"accepted_prefix_count\": 100,\n                        \"advertised_prefix_count\": 50,\n                    },\n                ],\n            },\n        }\n\n        collector.bgp(mock_driver)\n\n        self.assertTrue(\n            IPAddress.objects.filter(address=\"10.0.0.1/32\").exists()\n        )\n\n    def test_creates_asn_when_rir_exists(self):\n        \"\"\"bgp() should create ASN objects when a default RIR exists.\"\"\"\n        from ipam.models import IPAddress, ASN, RIR\n\n        rir = RIR.objects.create(name=\"TestRIR\", slug=\"testrir\")\n        device = Device.objects.create(\n            name=\"bgp-dev2\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n\n        plan = CollectionPlan.objects.create(\n            name=\"BGP Plan 2\",\n            collector_type=CollectionTypeChoices.TYPE_BGP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_bgp_neighbors_detail.return_value = {\n            \"global\": {\n                65001: [\n                    {\n                        \"up\": True,\n                        \"local_as\": 65000,\n                        \"remote_as\": 65001,\n                        \"remote_address\": \"10.1.0.1\",\n                        \"local_address\": \"10.1.0.2\",\n                        \"router_id\": \"10.1.0.1\",\n                        \"connection_state\": \"Established\",\n                        \"active_prefix_count\": 0,\n                        \"received_prefix_count\": 0,\n                        \"accepted_prefix_count\": 0,\n                        \"advertised_prefix_count\": 0,\n                    },\n                ],\n            },\n        }\n\n        collector.bgp(mock_driver)\n\n        self.assertTrue(ASN.objects.filter(asn=65001).exists())\n\n    def test_vrf_awareness(self):\n        \"\"\"bgp() should associate peer IPs with the correct VRF.\"\"\"\n        from ipam.models import IPAddress\n        from ipam.models.vrfs import VRF\n\n        vrf = VRF.objects.create(name=\"VRF_BGP\", rd=\"65000:100\")\n        device = Device.objects.create(\n            name=\"bgp-dev3\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n\n        plan = CollectionPlan.objects.create(\n            name=\"BGP Plan 3\",\n            collector_type=CollectionTypeChoices.TYPE_BGP,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.get_bgp_neighbors_detail.return_value = {\n            \"VRF_BGP\": {\n                65002: [\n                    {\n                        \"up\": True,\n                        \"local_as\": 65000,\n                        \"remote_as\": 65002,\n                        \"remote_address\": \"10.2.0.1\",\n                        \"local_address\": \"10.2.0.2\",\n                        \"router_id\": \"10.2.0.1\",\n                        \"connection_state\": \"Established\",\n                        \"active_prefix_count\": 0,\n                        \"received_prefix_count\": 0,\n                        \"accepted_prefix_count\": 0,\n                        \"advertised_prefix_count\": 0,\n                    },\n                ],\n            },\n        }\n\n        collector.bgp(mock_driver)\n\n        ip = IPAddress.objects.get(address=\"10.2.0.1/32\")\n        self.assertEqual(ip.vrf, vrf)\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-implement-bgp","title":"Step 2: Implement bgp()","text":"<p>Add imports at top of <code>collector.py</code>: <pre><code>from ipam.models import ASN, RIR\nfrom ipam.models.vrfs import VRF\n</code></pre></p> <pre><code>def bgp(self, driver: NetworkDriver):\n    \"\"\"Collect BGP neighbor data from a device.\"\"\"\n    bgp_data = driver.get_bgp_neighbors_detail()\n\n    for vrf_name, peers_by_as in bgp_data.items():\n        # Resolve VRF\n        vrf = None\n        if vrf_name and vrf_name not in (\"global\", \"default\"):\n            try:\n                vrf = VRF.objects.get(name=vrf_name)\n            except VRF.DoesNotExist:\n                self._log_warning(f\"VRF `{vrf_name}` not found in NetBox.\")\n\n        for remote_as_number, peer_list in peers_by_as.items():\n            # Try to find or create ASN\n            asn_obj = None\n            try:\n                asn_obj = ASN.objects.get(asn=remote_as_number)\n            except ASN.DoesNotExist:\n                # Try to create with first available RIR\n                default_rir = RIR.objects.first()\n                if default_rir:\n                    asn_obj, created = ASN.objects.get_or_create(\n                        asn=remote_as_number,\n                        defaults={\"rir\": default_rir},\n                    )\n                    if created:\n                        self._log_success(f\"Created ASN {remote_as_number}.\")\n                else:\n                    self._log_info(\n                        f\"No RIR exists in NetBox. Skipping ASN {remote_as_number} creation.\"\n                    )\n\n            for peer_data in peer_list:\n                peer_ip = peer_data.get(\"remote_address\", \"\")\n                if not peer_ip:\n                    continue\n\n                # Create/find peer IPAddress\n                ip_obj, created = IPAddress.objects.get_or_create(\n                    address=f\"{peer_ip}/32\",\n                    vrf=vrf,\n                    defaults={\n                        \"description\": (\n                            f\"BGP peer AS{remote_as_number} discovered on \"\n                            f\"{self._current_device} ({self._now.date()})\"\n                        ),\n                    },\n                )\n                if created:\n                    ip_obj.tags.add(AUTO_D_TAG)\n                    self._log_success(\n                        f\"Created peer IP {get_absolute_url_markdown(ip_obj, bold=True)} \"\n                        f\"(AS{remote_as_number}).\"\n                    )\n                else:\n                    self._log_info(\n                        f\"Found existing peer IP {get_absolute_url_markdown(ip_obj, bold=True)}.\"\n                    )\n\n                # Create journal entry with BGP session details\n                state = peer_data.get(\"connection_state\", \"Unknown\")\n                prefixes = peer_data.get(\"accepted_prefix_count\", 0)\n                JournalEntry.objects.create(\n                    created=self._now,\n                    assigned_object=ip_obj,\n                    kind=JournalEntryKindChoices.KIND_INFO,\n                    comments=(\n                        f\"BGP session from {get_absolute_url_markdown(self._current_device, bold=True)}: \"\n                        f\"State: `{state}`, AS: `{remote_as_number}`, \"\n                        f\"Accepted prefixes: `{prefixes}`\"\n                        + (f\", VRF: `{vrf_name}`\" if vrf else \"\")\n                    ),\n                )\n\n                # Conditional netbox-routing integration (see Task 11)\n                self._bgp_routing_integration(peer_data, ip_obj, asn_obj, vrf)\n\n    self._log_success(\"BGP collection completed\")\n\ndef _bgp_routing_integration(self, peer_data, ip_obj, asn_obj, vrf):\n    \"\"\"Hook for netbox-routing BGP integration. Implemented in Task 11.\"\"\"\n    pass\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests-and-commit_2","title":"Step 3: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement bgp() collector with ASN and VRF support\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-9-vendor-dispatch-framework--l2_circuits-junos","title":"Task 9: Vendor Dispatch Framework + l2_circuits() Junos","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/napalm/junos.py</code> - Modify: <code>netbox_facts/napalm/utils/junos_views.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-tests-for-vendor-dispatch--l2_circuits","title":"Step 1: Write tests for vendor dispatch + l2_circuits","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>class VendorDispatchTest(TestCase):\n    \"\"\"Tests for the vendor-specific dispatch mechanism.\"\"\"\n\n    def _make_collector(self, driver_name=\"junos\"):\n        plan = MagicMock()\n        plan.napalm_driver = driver_name\n        plan.collector_type = \"l2_circuits\"\n\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = \"l2_circuits\"\n        collector._now = timezone.now()\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        return collector\n\n    def test_dispatch_junos(self):\n        \"\"\"_get_vendor_method() should return Junos implementation for junos driver.\"\"\"\n        collector = self._make_collector(\"junos\")\n        method = collector._get_vendor_method(\"l2_circuits\")\n        self.assertTrue(callable(method))\n\n    def test_dispatch_enhanced_junos(self):\n        \"\"\"_get_vendor_method() should work for netbox_facts.napalm.junos driver.\"\"\"\n        collector = self._make_collector(\"netbox_facts.napalm.junos\")\n        method = collector._get_vendor_method(\"l2_circuits\")\n        self.assertTrue(callable(method))\n\n    def test_dispatch_unsupported_driver(self):\n        \"\"\"_get_vendor_method() should raise NotImplementedError for unsupported drivers.\"\"\"\n        collector = self._make_collector(\"eos\")\n        with self.assertRaises(NotImplementedError):\n            collector._get_vendor_method(\"l2_circuits\")\n\n\nclass L2CircuitsCollectorTest(TestCase):\n    \"\"\"Tests for the l2_circuits() Junos collector.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"L2C Site\", slug=\"l2c-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"L2CMfg\", slug=\"l2cmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"L2CModel\", slug=\"l2cmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"L2CRole\", slug=\"l2crole\")\n\n    def _make_collector(self, plan):\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_l2_circuits_creates_journal_entry(self):\n        \"\"\"l2_circuits() should create journal entries for discovered circuits.\"\"\"\n        device = Device.objects.create(\n            name=\"l2c-dev1\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"L2C Plan\",\n            collector_type=CollectionTypeChoices.TYPE_L2CIRCTUITS,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        # Mock the Junos L2 circuit data structure\n        mock_driver.cli.return_value = {\n            \"show l2circuit connections\": (\n                \"Legend for connection status (active = Up)\\n\"\n                \"Neighbor: 10.0.0.1\\n\"\n                \"  Interface: ge-0/0/0.100\\n\"\n                \"  Type: rmt  Status: Up  Circuit-ID: 100\\n\"\n            )\n        }\n\n        collector.l2_circuits(mock_driver)\n\n        entries = JournalEntry.objects.filter(assigned_object_id=device.pk)\n        self.assertTrue(entries.exists())\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-implement-vendor-dispatch--l2_circuits","title":"Step 2: Implement vendor dispatch + l2_circuits","text":"<p>Add to <code>netbox_facts/helpers/collector.py</code>:</p> <pre><code>def _get_vendor_method(self, method_name):\n    \"\"\"\n    Get vendor-specific implementation based on NAPALM driver.\n\n    To add support for a new vendor:\n    1. Implement a method named _{method_name}_{vendor}(self, driver)\n    2. Add the driver name to the vendor_map below\n\n    Example for adding EOS support for l2_circuits:\n        def _l2_circuits_eos(self, driver):\n            ...\n        # Then add to vendor_map: 'eos': f'_{method_name}_eos'\n    \"\"\"\n    vendor_map = {\n        \"junos\": f\"_{method_name}_junos\",\n        \"netbox_facts.napalm.junos\": f\"_{method_name}_junos\",\n    }\n    driver_name = self.plan.napalm_driver\n    impl_name = vendor_map.get(driver_name)\n    if impl_name and hasattr(self, impl_name):\n        return getattr(self, impl_name)\n    supported = [k for k, v in vendor_map.items() if hasattr(self, v)]\n    raise NotImplementedError(\n        f\"{method_name} is not implemented for driver '{driver_name}'. \"\n        f\"Supported drivers: {supported}\"\n    )\n\ndef l2_circuits(self, driver: NetworkDriver):\n    \"\"\"Collect L2 circuit data. Dispatches to vendor-specific implementation.\"\"\"\n    impl = self._get_vendor_method(\"l2_circuits\")\n    impl(driver)\n\ndef _l2_circuits_junos(self, driver):\n    \"\"\"Junos L2 circuit collection via CLI.\"\"\"\n    try:\n        output = driver.cli([\"show l2circuit connections\"])\n        raw = output.get(\"show l2circuit connections\", \"\")\n    except Exception as exc:\n        self._log_failure(f\"Failed to retrieve L2 circuit data: {exc}\")\n        return\n\n    if not raw.strip():\n        self._log_info(\"No L2 circuit data found.\")\n        return\n\n    # Parse the L2 circuit output and create journal entry\n    JournalEntry.objects.create(\n        created=self._now,\n        assigned_object=self._current_device,\n        kind=JournalEntryKindChoices.KIND_INFO,\n        comments=f\"L2 circuit data collected:\\n```\\n{raw[:2000]}\\n```\",\n    )\n    self._log_success(\"L2 circuit collection completed\")\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests-and-commit_3","title":"Step 3: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Add vendor dispatch framework and l2_circuits() Junos collector\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-10-implement-evpn-junos-collector","title":"Task 10: Implement evpn() Junos Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests_5","title":"Step 1: Write failing tests","text":"<pre><code>class EVPNCollectorTest(TestCase):\n    \"\"\"Tests for the evpn() Junos collector.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"EVPN Site\", slug=\"evpn-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"EVPNMfg\", slug=\"evpnmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"EVPNModel\", slug=\"evpnmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"EVPNRole\", slug=\"evpnrole\")\n\n    def _make_collector(self, plan):\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_evpn_creates_mac_with_evpn_discovery(self):\n        \"\"\"evpn() should create MACAddress objects with discovery_method='evpn'.\"\"\"\n        from netbox_facts.models import MACAddress\n\n        device = Device.objects.create(\n            name=\"evpn-dev1\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"EVPN Plan\",\n            collector_type=CollectionTypeChoices.TYPE_EVPN,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.cli.return_value = {\n            \"show evpn mac-table\": (\n                \"MAC address      Logical interface   NH Index  Flags\\n\"\n                \"AA:BB:CC:DD:11:22  vtep.32769         0         D\\n\"\n                \"AA:BB:CC:DD:33:44  vtep.32769         0         D\\n\"\n            )\n        }\n\n        collector.evpn(mock_driver)\n\n        # Should create MAC entries\n        self.assertTrue(MACAddress.objects.filter(mac_address=\"AA:BB:CC:DD:11:22\").exists())\n        mac = MACAddress.objects.get(mac_address=\"AA:BB:CC:DD:11:22\")\n        self.assertEqual(mac.discovery_method, CollectionTypeChoices.TYPE_EVPN)\n\n    def test_evpn_unsupported_driver(self):\n        \"\"\"evpn() should raise NotImplementedError for non-Junos drivers.\"\"\"\n        plan = MagicMock()\n        plan.napalm_driver = \"eos\"\n        plan.collector_type = CollectionTypeChoices.TYPE_EVPN\n\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = CollectionTypeChoices.TYPE_EVPN\n        collector._now = timezone.now()\n        collector._current_device = None\n        collector._log_prefix = \"\"\n\n        with self.assertRaises(NotImplementedError):\n            collector.evpn(MagicMock())\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-implement-evpn","title":"Step 2: Implement evpn()","text":"<pre><code>def evpn(self, driver: NetworkDriver):\n    \"\"\"Collect EVPN data. Dispatches to vendor-specific implementation.\"\"\"\n    impl = self._get_vendor_method(\"evpn\")\n    impl(driver)\n\ndef _evpn_junos(self, driver):\n    \"\"\"Junos EVPN collection via CLI.\"\"\"\n    try:\n        output = driver.cli([\"show evpn mac-table\"])\n        raw = output.get(\"show evpn mac-table\", \"\")\n    except Exception as exc:\n        self._log_failure(f\"Failed to retrieve EVPN data: {exc}\")\n        return\n\n    if not raw.strip():\n        self._log_info(\"No EVPN data found.\")\n        return\n\n    # Parse MAC addresses from EVPN table\n    import re as _re\n    mac_pattern = _re.compile(r\"([0-9A-Fa-f]{2}(?::[0-9A-Fa-f]{2}){5})\")\n    for line in raw.strip().split(\"\\n\"):\n        match = mac_pattern.search(line)\n        if match:\n            mac_str = match.group(1)\n            netbox_mac, created = MACAddress.objects.get_or_create(\n                mac_address=mac_str\n            )\n            netbox_mac.discovery_method = CollectionTypeChoices.TYPE_EVPN\n            netbox_mac.last_seen = self._now\n            netbox_mac.save()\n\n            if created:\n                netbox_mac.tags.add(AUTO_D_TAG)\n                self._log_success(\n                    f\"Created EVPN MAC {get_absolute_url_markdown(netbox_mac, bold=True)}.\"\n                )\n\n    # Create journal entry with raw data\n    JournalEntry.objects.create(\n        created=self._now,\n        assigned_object=self._current_device,\n        kind=JournalEntryKindChoices.KIND_INFO,\n        comments=f\"EVPN data collected:\\n```\\n{raw[:2000]}\\n```\",\n    )\n    self._log_success(\"EVPN collection completed\")\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests-and-commit_4","title":"Step 3: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement evpn() Junos collector\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-11-implement-ospf-junos-collector","title":"Task 11: Implement ospf() Junos Collector","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>netbox_facts/tests/test_helpers.py</code></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-write-failing-tests_6","title":"Step 1: Write failing tests","text":"<pre><code>class OSPFCollectorTest(TestCase):\n    \"\"\"Tests for the ospf() Junos collector.\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.site = Site.objects.create(name=\"OSPF Site\", slug=\"ospf-site\")\n        cls.manufacturer = Manufacturer.objects.create(name=\"OSPFMfg\", slug=\"ospfmfg\")\n        cls.device_type = DeviceType.objects.create(\n            manufacturer=cls.manufacturer, model=\"OSPFModel\", slug=\"ospfmodel\"\n        )\n        cls.role = DeviceRole.objects.create(name=\"OSPFRole\", slug=\"ospfrole\")\n\n    def _make_collector(self, plan):\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = plan.collector_type\n        collector._napalm_args = {}\n        collector._napalm_driver = None\n        collector._napalm_username = \"test\"\n        collector._napalm_password = \"test\"\n        import re\n        collector._interfaces_re = re.compile(r\".*\")\n        collector._devices = []\n        collector._current_device = None\n        collector._log_prefix = \"\"\n        collector._now = timezone.now()\n        return collector\n\n    def test_ospf_creates_journal_entry(self):\n        \"\"\"ospf() should create journal entries for discovered neighbors.\"\"\"\n        device = Device.objects.create(\n            name=\"ospf-dev1\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"OSPF Plan\",\n            collector_type=CollectionTypeChoices.TYPE_OSPF,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.cli.return_value = {\n            \"show ospf neighbor\": (\n                \"Address          Interface              State     ID               Pri  Dead\\n\"\n                \"10.0.0.1         ge-0/0/0.0             Full      10.0.0.1         128    35\\n\"\n                \"10.0.0.2         ge-0/0/1.0             Full      10.0.0.2         128    33\\n\"\n            )\n        }\n\n        collector.ospf(mock_driver)\n\n        entries = JournalEntry.objects.filter(assigned_object_id=device.pk)\n        self.assertTrue(entries.exists())\n\n    def test_ospf_creates_peer_ips(self):\n        \"\"\"ospf() should create IPAddress objects for OSPF neighbors.\"\"\"\n        from ipam.models import IPAddress\n\n        device = Device.objects.create(\n            name=\"ospf-dev2\", site=self.site,\n            device_type=self.device_type, role=self.role,\n        )\n        plan = CollectionPlan.objects.create(\n            name=\"OSPF Plan 2\",\n            collector_type=CollectionTypeChoices.TYPE_OSPF,\n            napalm_driver=\"junos\",\n            device_status=[DeviceStatusChoices.STATUS_ACTIVE],\n        )\n        collector = self._make_collector(plan)\n        collector._current_device = device\n\n        mock_driver = MagicMock()\n        mock_driver.cli.return_value = {\n            \"show ospf neighbor\": (\n                \"Address          Interface              State     ID               Pri  Dead\\n\"\n                \"10.0.0.1         ge-0/0/0.0             Full      10.0.0.1         128    35\\n\"\n            )\n        }\n\n        collector.ospf(mock_driver)\n\n        self.assertTrue(IPAddress.objects.filter(address=\"10.0.0.1/32\").exists())\n\n    def test_ospf_unsupported_driver(self):\n        \"\"\"ospf() should raise NotImplementedError for non-Junos drivers.\"\"\"\n        plan = MagicMock()\n        plan.napalm_driver = \"eos\"\n        plan.collector_type = CollectionTypeChoices.TYPE_OSPF\n\n        with patch.object(NapalmCollector, \"__init__\", lambda self, p: None):\n            collector = NapalmCollector.__new__(NapalmCollector)\n        collector.plan = plan\n        collector._collector_type = CollectionTypeChoices.TYPE_OSPF\n        collector._now = timezone.now()\n        collector._current_device = None\n        collector._log_prefix = \"\"\n\n        with self.assertRaises(NotImplementedError):\n            collector.ospf(MagicMock())\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-implement-ospf","title":"Step 2: Implement ospf()","text":"<pre><code>def ospf(self, driver: NetworkDriver):\n    \"\"\"Collect OSPF data. Dispatches to vendor-specific implementation.\"\"\"\n    impl = self._get_vendor_method(\"ospf\")\n    impl(driver)\n\ndef _ospf_junos(self, driver):\n    \"\"\"Junos OSPF collection via CLI.\"\"\"\n    try:\n        output = driver.cli([\"show ospf neighbor\"])\n        raw = output.get(\"show ospf neighbor\", \"\")\n    except Exception as exc:\n        self._log_failure(f\"Failed to retrieve OSPF data: {exc}\")\n        return\n\n    if not raw.strip():\n        self._log_info(\"No OSPF neighbor data found.\")\n        return\n\n    # Parse OSPF neighbor IPs\n    import re as _re\n    ip_pattern = _re.compile(r\"^(\\d+\\.\\d+\\.\\d+\\.\\d+)\\s+(\\S+)\\s+(\\S+)\\s+(\\d+\\.\\d+\\.\\d+\\.\\d+)\", _re.MULTILINE)\n    neighbors = []\n    for match in ip_pattern.finditer(raw):\n        neighbor_ip = match.group(1)\n        iface_name = match.group(2)\n        state = match.group(3)\n        router_id = match.group(4)\n        neighbors.append({\n            \"address\": neighbor_ip,\n            \"interface\": iface_name,\n            \"state\": state,\n            \"router_id\": router_id,\n        })\n\n        # Create/find neighbor IP\n        ip_obj, created = IPAddress.objects.get_or_create(\n            address=f\"{neighbor_ip}/32\",\n            defaults={\n                \"description\": (\n                    f\"OSPF neighbor (Router ID: {router_id}) discovered on \"\n                    f\"{self._current_device} ({self._now.date()})\"\n                ),\n            },\n        )\n        if created:\n            ip_obj.tags.add(AUTO_D_TAG)\n            self._log_success(\n                f\"Created OSPF neighbor IP {get_absolute_url_markdown(ip_obj, bold=True)} \"\n                f\"(Router ID: {router_id}).\"\n            )\n\n        # Conditional netbox-routing integration (see Task 12)\n        self._ospf_routing_integration(ip_obj, neighbors[-1])\n\n    # Create journal entry\n    if neighbors:\n        neighbor_lines = \"\\n\".join(\n            f\"- `{n['address']}` on `{n['interface']}` (State: {n['state']}, \"\n            f\"Router ID: {n['router_id']})\"\n            for n in neighbors\n        )\n        JournalEntry.objects.create(\n            created=self._now,\n            assigned_object=self._current_device,\n            kind=JournalEntryKindChoices.KIND_INFO,\n            comments=f\"OSPF neighbors discovered:\\n{neighbor_lines}\",\n        )\n\n    self._log_success(\"OSPF collection completed\")\n\ndef _ospf_routing_integration(self, ip_obj, neighbor_data):\n    \"\"\"Hook for netbox-routing OSPF integration. Implemented in Task 12.\"\"\"\n    pass\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-run-tests-and-commit_5","title":"Step 3: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py\ngit commit -m \"Implement ospf() Junos collector\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-12-add-netbox-routing-integration","title":"Task 12: Add netbox-routing Integration","text":"<p>Files: - Modify: <code>netbox_facts/helpers/collector.py</code> - Modify: <code>.devcontainer/Dockerfile-plugin_dev</code> (or equivalent) - Modify: <code>netbox_facts/tests/test_helpers.py</code></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-add-netbox-routing-to-devcontainer","title":"Step 1: Add netbox-routing to devcontainer","text":"<p>In the Dockerfile or setup, add: <pre><code>uv pip install netbox-routing\n</code></pre></p> <p>Also add to <code>pyproject.toml</code> optional dependencies: <pre><code>[project.optional-dependencies]\nrouting = [\"netbox-routing\"]\ndev = [\"netbox-routing\", ...]  # add to existing dev deps\n</code></pre></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-write-tests-for-conditional-integration","title":"Step 2: Write tests for conditional integration","text":"<p>Add to <code>netbox_facts/tests/test_helpers.py</code>:</p> <pre><code>class NetboxRoutingIntegrationTest(TestCase):\n    \"\"\"Tests for conditional netbox-routing integration.\"\"\"\n\n    def test_bgp_integration_when_available(self):\n        \"\"\"When netbox-routing is installed, BGP integration should attempt to use it.\"\"\"\n        try:\n            from netbox_routing.models import BGPPeer\n            routing_available = True\n        except ImportError:\n            routing_available = False\n\n        # This test verifies the detection mechanism works\n        from netbox_facts.helpers.collector import _has_netbox_routing\n        self.assertEqual(_has_netbox_routing(), routing_available)\n\n    def test_bgp_integration_fallback(self):\n        \"\"\"BGP collector should work without netbox-routing.\"\"\"\n        # The bgp() method from Task 8 should work regardless\n        # This is already covered by BGPCollectorTest\n        pass\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-implement-netbox-routing-detection-and-integration-hooks","title":"Step 3: Implement netbox-routing detection and integration hooks","text":"<p>Add at top of <code>netbox_facts/helpers/collector.py</code>:</p> <pre><code>def _has_netbox_routing():\n    \"\"\"Check if netbox-routing plugin is installed.\"\"\"\n    try:\n        import netbox_routing  # noqa: F401\n        return True\n    except ImportError:\n        return False\n</code></pre> <p>Replace the <code>_bgp_routing_integration</code> stub:</p> <pre><code>def _bgp_routing_integration(self, peer_data, ip_obj, asn_obj, vrf):\n    \"\"\"Create/update BGP session in netbox-routing if available.\"\"\"\n    if not _has_netbox_routing():\n        return\n\n    try:\n        from netbox_routing.models import BGPPeer, BGPRouter, BGPScope\n\n        # Find or create BGP router for local device\n        router = BGPRouter.objects.filter(\n            assigned_object_id=self._current_device.pk,\n        ).first()\n        if not router:\n            self._log_info(\n                f\"No BGPRouter found for {self._current_device} in netbox-routing. \"\n                f\"Skipping BGP session creation.\"\n            )\n            return\n\n        # Find or create scope (VRF context)\n        scope = BGPScope.objects.filter(router=router, vrf=vrf).first()\n        if not scope:\n            self._log_info(\n                f\"No BGPScope found for router {router} \"\n                + (f\"in VRF {vrf}\" if vrf else \"in global table\")\n                + \". Skipping BGP session creation.\"\n            )\n            return\n\n        remote_as = peer_data.get(\"remote_as\")\n        # Check if peer already exists\n        existing = BGPPeer.objects.filter(\n            scope=scope,\n            peer=ip_obj,\n        ).first()\n        if existing:\n            self._log_info(\n                f\"BGP peer already exists in netbox-routing for {ip_obj}.\"\n            )\n            return\n\n        peer = BGPPeer.objects.create(\n            name=f\"AS{remote_as} - {ip_obj}\",\n            scope=scope,\n            peer=ip_obj,\n            remote_as=remote_as,\n            enabled=peer_data.get(\"up\", False),\n        )\n        self._log_success(\n            f\"Created BGP peer in netbox-routing: {peer.name}\"\n        )\n\n    except Exception as exc:\n        self._log_warning(\n            f\"netbox-routing BGP integration error: {exc}\"\n        )\n</code></pre> <p>Replace the <code>_ospf_routing_integration</code> stub:</p> <pre><code>def _ospf_routing_integration(self, ip_obj, neighbor_data):\n    \"\"\"Create/update OSPF data in netbox-routing if available.\"\"\"\n    if not _has_netbox_routing():\n        return\n\n    try:\n        from netbox_routing.models import OSPFInstance\n\n        # Just log that we found OSPF neighbor \u2014 full integration\n        # requires OSPFInstance to be pre-configured in netbox-routing\n        instance = OSPFInstance.objects.filter(\n            device=self._current_device,\n        ).first()\n        if instance:\n            self._log_info(\n                f\"Found OSPF instance `{instance}` for {self._current_device} \"\n                f\"in netbox-routing. Neighbor: {neighbor_data['address']} \"\n                f\"(State: {neighbor_data['state']})\"\n            )\n\n    except Exception as exc:\n        self._log_warning(\n            f\"netbox-routing OSPF integration error: {exc}\"\n        )\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-4-run-tests-and-commit","title":"Step 4: Run tests and commit","text":"<pre><code>make test\ngit add netbox_facts/helpers/collector.py netbox_facts/tests/test_helpers.py .devcontainer/ pyproject.toml\ngit commit -m \"Add conditional netbox-routing integration for BGP and OSPF\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#task-13-final-integration-test--cleanup","title":"Task 13: Final Integration Test + Cleanup","text":"<p>Files: - All modified files from previous tasks - Run full test suite</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-1-run-the-full-test-suite","title":"Step 1: Run the full test suite","text":"<pre><code>make test\n</code></pre> <p>Verify all tests pass and migration check is clean.</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-2-verify-the-collector-dispatch-in-execute","title":"Step 2: Verify the collector dispatch in execute()","text":"<p>Check that <code>execute()</code> in <code>collector.py</code> correctly dispatches to all new methods. The existing <code>getattr(self, self._collector_type)(driver)</code> pattern should work because: - <code>self._collector_type</code> is one of: <code>arp</code>, <code>ndp</code>, <code>inventory</code>, <code>interfaces</code>, <code>lldp</code>, <code>ethernet_switching</code>, <code>l2_circuits</code>, <code>evpn</code>, <code>bgp</code>, <code>ospf</code> - Each of these is now a method on <code>NapalmCollector</code></p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-3-verify-signal-and-jobrunner-import-chain","title":"Step 3: Verify signal and JobRunner import chain","text":"<p>Check that <code>__init__.py</code> imports <code>signals</code> (it does \u2014 line 31-33), and that the signal handler correctly imports <code>CollectionJobRunner</code> at call time (lazy import to avoid circular dependency).</p>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#step-4-final-commit-if-any-cleanup-needed","title":"Step 4: Final commit if any cleanup needed","text":"<pre><code>make test\ngit add -A\ngit commit -m \"Final integration cleanup for Phase 2+3\"\n</code></pre>"},{"location":"plans/2026-02-26-phase2-phase3-implementation/#summary-of-implementation-order","title":"Summary of Implementation Order","text":"Task Description Key Files 1 Add OSPF choice + migration <code>choices.py</code>, migration 2 JobRunner refactor <code>jobs.py</code>, <code>collection_plan.py</code>, <code>test_jobs.py</code> 3 Auto-scheduling signal <code>signals.py</code>, <code>test_signals.py</code> 4 inventory() collector <code>collector.py</code>, <code>test_helpers.py</code> 5 interfaces() collector <code>collector.py</code>, <code>test_helpers.py</code> 6 ethernet_switching() <code>collector.py</code>, <code>test_helpers.py</code> 7 lldp() collector <code>collector.py</code>, <code>test_helpers.py</code> 8 bgp() collector <code>collector.py</code>, <code>test_helpers.py</code> 9 Vendor dispatch + l2_circuits <code>collector.py</code>, <code>test_helpers.py</code> 10 evpn() Junos <code>collector.py</code>, <code>test_helpers.py</code> 11 ospf() Junos <code>collector.py</code>, <code>test_helpers.py</code> 12 netbox-routing integration <code>collector.py</code>, devcontainer, <code>test_helpers.py</code> 13 Final integration test All"}]}